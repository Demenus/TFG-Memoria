% Chapter Template

\definecolor{mybluei}{RGB}{124,156,205}
\definecolor{myblueii}{RGB}{73,121,193}
\definecolor{mygreen}{RGB}{202,217,126}
\definecolor{mypink}{RGB}{233,198,235}

% this length is used to control the width of the light blue frame
% for the upper part of the diagram
\newlength\myframesep
\setlength\myframesep{8pt}

\pgfdeclarelayer{background}
\pgfsetlayers{background,main}

\pgfkeys{
    /tikz/node distance/.append code={
        \pgfkeyssetvalue{/tikz/node distance value}{#1}
    }
}

\newcommand\widernode[5][blueb]{
\node[
        #1,
        inner sep=0pt,
        shift=($(#2.south)-(#2.north)$),
        yshift=-\pgfkeysvalueof{/tikz/node distance value},
        fit={(#2) (#3)},
        label=center:{\sffamily\bfseries\color{white}#4}] (#5) {};
}

\chapter{\robotto} % Main chapter title

\label{Chapter2} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Cap\'itulo 2. \emph{\robotto}} % Change X to a consecutive number; this is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

Ahora que se conoce la finalidad de \robotto se procederá a explicar su funcionamiento, sus partes, y como estas se relacionan entre sí

\section{Diseño de \robotto}

A lo largo de esta sección se explicarán las distintas decisiones en el diseño de \robotto. Tal y como se aprecia en el esquema principal, ver \ref{fig:Esquema}, se buscan varios objetivos.\\
Por una parte se quiere poder portar desde un software de edición 3D como blender a un formato propio y este a su vez que sea fácil de editar proporcionando un editor capaz de ello. \\
Por otra parte se busca desacoplar la interfaz que usará el usuario del núcleo del motor proporcionando así seguridad de uso y una interfaz estable abierta a la extensión pero cerrada a la modificación.\\
Además, y tal y como se espera de un motor de gráficos 3D, está la gestión de la escena y de los recursos para una correcta visualización.\\
Y por último, pero no menos importante, la capacidad de interactuar con eventos procedentes del dispositivo.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.4]{esquema.png}
\end{center}
\caption[Esquema principal de \robotto]{Esquema principal de \robotto}
\label{fig:Esquema}
\end{figure}

\subsection{Formato .MRR}
La decisión de usar un formato propio frente a usar alguno ya ampliamente aceptado como podría ser \textit{.fbx} o \textit{.dae} viene fomentado por la necesidad de controlar en su totalidad los distintos datos y sobretodo, la forma en la que estos se almacenarán dentro de una aplicación.\\

Por ejemplo de cara al rendimiento se decidió almacenar los vértices de forma intercalada tal y como se recomienda en \cite{1misc} a la vez que usar en todo momento \textit{Index Buffer Objects} como se recomienda en \cite{2misc}.\\
También se tomó en cuenta la necesidad de modificar la configuración de cómo se mostrará la escena sin necesidad de código, si no la realización de esta mediante un fichero. Por ejemplo, gracias al formato MRR se puede decidir si una malla va a ser dibujada usando triángulos o bien líneas únicamente.\\

Aún así estas no son las únicas razones para proporcionar un formato propio, algunas de las citadas configuraciones podrían llevarse a cabo fácilmente haciendo uso de otros tipos de formatos más comunes. El mayor motivo detrás de la creación del formato MRR es la creación de un formato que fuera \textit{Scene Object Centric}.\\
Con este término, \textit{Scene Object Centric}, se hace alusión a un diseño centrado en los objetos de la escena, donde cada elemento es independiente del resto de elementos que pudiesen estar definidos en ella. De esta forma la tarea de comunicar un objeto con otro recae sobre el motor y no es arrastrada desde el formato.
Únicamente hay un único punto de conexión entre los objetos y este se realiza mediante los denominados \hyperref[susec:UnifKeyUnifGen]{UniformKeys y UniformsGenerators}

Toda la información acerca del formato y cómo está organizada la información almacenada en él puede verse en \ref{AppendixA}

\subsection{El SceneTree}
El SceneTree es la estructura fundamental de almacenamiento de los objetos de la escena.\\
Posee una estructura de árbol donde cada nodo puede tener un número variable de hijos, pero lo que lo diferencia de una estructura de árbol normal es que sus nodos se encuentran indexados tanto por el nombre del dato almacenado en el nodo como por su tipo, permitiendo así realizar búsquedas dentro de la estructura en $O(1)$\\
Su funcionamiento se explicará de forma detallada en \ref{susec:MrSceneTree}

\subsection{Elementos de una Escena}
Para los elementos constituyentes de una escena 3D se decidió emular el diseño de componentes de otros motores 3D a la vez que la necesidad de que la API fuese lo más sencilla y funcional que se pudiera.\\

\subsubsection{Object}
Los objetos genéricos tienen la función de ser la base de la jerarquía del resto de objetos de la escena, y en él ser verán reflejados todas las acciones compartidas. A saber:

\begin{itemize}
\item Gestión de las transformaciones geométricas:\newline
Se espera que un objeto de una escena pueda ser transformado por traslaciones, rotaciones y escalados dentro de la escena que los contiene.
\item Inicialización:\newline
La inicialización de los objetos de la escena hace referencia a varias acciones que deben ser llevadas a cabo antes del uso del objeto, a saber estas pueden ser:
\begin{itemize}
\item Establecimiento del comportamiento de los objetos frente a los eventos
\item Configuración de ciertos elementos en la GPU, como podría ser iniciar un Vertex Buffer Object.
\item Configuración previa dependiente del tamaño de la ventana donde va a realizarse el dibujado de la escena, como por ejemplo, la creación de la matriz de proyección.
\end{itemize}
\item Actualización de los diferentes elementos que dependen de él en cada ciclo de renderizado, como podría ser la gestión de eventos o envío de datos a la GPU
\item Métodos de comunicación con la escena y otros objetos
\end{itemize}

\subsubsection{Model}
Los modelos 3D son seguramente el elemento más representativos dentro del motor puesto que son los únicos elementos realmente visibles de la escena.\\
Los modelos no representan únicamente las mallas tridimensionales visibles en el mundo, si no que además engloba otras funcionalidades tales como

\begin{itemize}
\item Gestión de la visualización final:\\
Un modelo será capaz de gestionar como será su aspecto final en la escena, es decir, un modelo será capaz de hacer uso de un sombreador (\textit{Shader}) independiente al resto.
\item Gestión de las animaciones:\\
En el caso de que el modelo tuviera animaciones basadas en esqueleto, es el modelo quien tiene el control sobre este.\\
En otros motores los esqueletos suelen manejarse de forma independiente al resto de elementos y como un objeto de la escena más, pero en el caso de \robotto se decidió que un esqueleto carece de sentido si no existe un modelo sobre el cuál se aplique.
\item Gestión de materiales y texturas:\\
Las texturas y materiales utilizados en cada modelo, aunque puedan ser compartidos entre multipes modelos, es tarea de cada uno el controlar la textura o material usado en cada momento.
\end{itemize}

\subsubsection{Cámaras y Luces}
La cámara es el objeto de escena encargado de proporcionar el punto de vista a través del cual será visualizado el mundo.\\
Además de ello también ofrece el tipo de proyección a utilizar, a escoger entre ortogonal y perspectiva.\\

Por otra parte las luces son los objetos de la escena encargados de proporcionar la iluminación \\

\subsubsection{Scene}
Posiblemente este es el objeto más conflictivo conceptualmente ya que no parece posible que la escena sea considerada como un objeto de la escena, sin embargo hay una justificación para esta decisión.\\
Aunque la escena no genere estrictamente hablando un cambio visible si se decide hacer una transformación geométrica sobre ella, o al reaccionar frente a un evento, la finalidad de que sea considerada como objeto de la escena es que de esa manera es posible configurar algunos aspectos visibles con datos procedentes desde el fichero MRR. Es decir, de esta forma algunos atributos como por ejemplo el color plano con el que se limpia la escena puede cambiarse en la configuración y no desde código.\\
Aún así existen más motivos que justifican esta decisión, y es que la escena, conceptualmente, es un buen lugar donde albergar la responsabilidad de la generación de uniforms que sean dependientes de varios objetos. Este concepto se explica en la siguiente apartado.

\subsection{Los Conceptos de UniformKey y UniformGenerator}\label{susec:UnifKeyUnifGen}
En este apartado se tratará cómo se realiza el envío de datos desde CPU a GPU.\\
Con este fin se ha implementado en \robotto tres elementos muy relacionados entre sí.\\
\begin{itemize}
\item En primer lugar se tienen los \textbf{Uniforms}, que no son si no una representación de los \textit{uniforms} usados en los \textit{Shader Programs}.\\
Dichos Uniforms poseen, entre otras cosas, dos campos fundamentales que hacen posible la comunicación
\begin{itemize}
\item El \texttt{UniformType}, que determina el tipo uniform al que se hace referencia, como podría ser la matriz de proyección o la \textit{ModelView Matrix}.\\
Podría pensarse que este papel ya es desempeñado por el nombre del uniform dentro del \textit{Shader Program}, sin embargo, definiendo el tipo del Uniform de esta forma permite que distintos \textit{Shader Programs} puedan requerir un mismo Uniform sin necesidad de que su código presente las mismas variables obligatoriamente.
\item El \texttt{UniformId} representa el identificador dado por la GPU de la variable \textit{uniform} en cuestión.
\end{itemize}
\item Por otra parte se tienen los \textbf{UniformGenerators}, estos elementos tienen como función principal asignarle a cada objeto la funcionalidad necesaria para generar los valores de los Uniforms que este objeto sea el encargado de producir. Por ejemplo, la cámara será la encargada de producir la \textit{View Matrix} pero no la \textit{Model View Matrix} ya que esta depende de la cámara y también de la \textit{Model Matrix}, la cuál es generada por un modelo.\\
Todo UniformGenerator poseera un identificador único dentro del conjunto de generadores de un objeto individual.
\item Por último está el elemento que actúa como puente entre los dos anteriormente detallados, los \textbf{UniformKeys}.\\
Entre las funciones de los UniformKeys las más destacables son:
\begin{itemize}
\item Almacenar el valor de los uniforms generados en los UniformGenerators.
\item Proporcionar información acerca de los uniforms que un objeto es capaz de generar.\\
De esta última afirmación se deduce que todo UniformKey ha de tener asociado obligatoriamente un UniformGenerator
\end{itemize}
Para conseguirlo el UniformKey cuenta con un campo que le permite enlazarse con el objeto Uniform, el ya comentado \texttt{UniformType} y por otra parte, otro campo que le permita comunicarse con su UniformGenerator asociado.
\end{itemize}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.4]{uniformsgeneratorsandkeys.png}
\end{center}
\caption[Funcionamiento de UniformKeys y UniformsGenerators]{Funcionamiento de UniformKeys y UniformsGeneratos.\\
1. Búsqueda del objeto con el UniformType capaz de generar el Uniform dado.\\
2. Búsqueda dentro del objeto del UniformGenerator asociado al UniformKey.\\
3. Generación del valor del Uniform.\\
4. Almacenamiento del valor dentro del UniformKey.\\
5. Envío a la GPU el valor del Uniform generado.}
\label{fig:unifkeysandgen}
\end{figure}

De estos elementos, tanto Uniforms como UniformKeys son proporcionados por el fichero MRR como una parte más de un objeto, sin embargo, los UniformGenerators, son proporcionados vía código. Algunos de estos UniformGenerators, o al menos, los más usuales son provistos por el propio motor, sin embargo, la API ofrece la posibilidad de que el usuario pueda crear un nuevo UniformGenerator así como modificar el comportamiento de alguno ya existente tal y como se explica en.\\
TODO: Dar la referencia en el documento de como crear un uniform generator\\

TODO: Explicar los niveles

TODO: Explicar caso del MVP

\subsection{La Necesidad del Rendering Context}
El \textbf{Rendering Context} es el elemento encargado organizar y optimizar los datos utilizados al dibujar la escena.\\

Una de sus principales funcionalidades es la de controlar la lista de UniformKeys requeridos por cada objeto a la hora del renderizado.

Además también posee un papel vital de cara al rendimiento, pues es el encargado de minimizar los cambios de estados de la GPU. Esto se consigue por una parte realizando una ordenación previa de los objetos de la escena, haciendo que el coste de todos los cambios de estados a realizar durante la generación de un frame sea el menor posible y por otra parte, controlando qué elementos se encuentran presentes en la GPU, tarea desempeñada por el Rendering Context.\\

Por ejemplo, se ordenan todos los modelos que posean la misma textura, esta se envía una única vez a la GPU y es usada por todos estos modelos de, de esa forma se minimizará el número de cambio de texturas.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.4]{renderingcontext.png}
\end{center}
\caption[Ejemplo del funcionamiento del Rendering Context]{Ejemplo del funcionamiento del Rendering Context}
\label{fig:renderingcontext}
\end{figure}

\subsection{Eventos}

\subsection{Algoritmo de Renderizado}
Ahora que se han tratado todos los conceptos fundamentales que definen el funcionamiento del motor se puede establecer el comportamiento del ciclo del renderizado desde su inicialización hasta la generación de la imagen final.\\

En primer lugar se presenta el esquema de inicialización de los elementos gráficos.\\
Como se puede apreciar en primer lugar se inicializan todos los objetos uno a uno, se hacen llamadas a la GPU como podrían ser compilaciones de Shader Programs o configuración de texturas,
tras ello se acude al RenderingSorter, encargado de ordenar los objetos de la escena en función del coste de los cambios de estado en la GPU.
Finalmente se realizan las inicializaciones que requieran conocer el tamaño de la ventana 

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.6]{initrender.png}
\end{center}
\caption[Inicialización de Recursos para el Renderizado]{Inicialización de Recursos para el Renderizado}
\label{fig:initrender}
\end{figure}

En el caso del renderizado de un frame lo primero que se realiza es actualizar el objeto según los eventos recibidos.\\
Tras ello tomamos el primer modelo de la lista de modelos ordenados generados en la inicialización y cargamos en la lista de UniformKeys todos los UniformKeys de este modelo y del resto de objetos activos, a saber: la cámara actual, las luces y la escena.\\
Una vez todos los UniformKeys han sido ordenados por nivel de dependencias se generan los valores de estos en los UniformGenerators y se envían a la GPU.

TODO: Editar y agregar la columna de model, recuerda que es para cada modelo
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.7]{renderrender.png}
\end{center}
\caption[Renderizado de un Frame]{Renderizado de un Frame}
\label{fig:renderrender}
\end{figure}




%-----------------------------------
%	SECTION 2
%-----------------------------------
\section{Arquitectura de \robotto}

\subsection{Interfaz de Uso}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.4]{interfaznucleo.png}
\end{center}
\caption[Interfaz del núcleo]{Interfaz del núcleo}
\label{fig:interfaznucleo}
\end{figure}

La interfaz de uso está compuesta por los elementos pensados para ser usados por los usuarios de \robotto.\\
Dichos elementos proveen al usuario de acciones comunes al tratar con objetos en una escena 3D como por ejemplo trasladar un objeto, rotarlo, ejecutar una animación,... U otras funcionalidades más generales como la búsqueda de objetos dentro de una escena, control de la jerarquía o de gestión de eventos.\\
Además, dichas herramientas son gestionadas de forma muy similar a como se gestiona el ciclo de vida de las aplicaciones Android comúnes, permitiendo mantener un paradigma similar al de la plataforma sobre la que se trabaja, intentando así que el usuario se sienta lo más cómodo posible a la hora de integrar \robotto en su aplicación.\\

\subsubsection{Integración en una Aplicación Android}

A la hora de integrar \robotto dentro de una aplicación Android \rorefrobottoengine\label{ro:robottoengine} es sin duda el primer objeto con el que se encuentra el usuario al usar \robotto. Es el encargado de la gestión del ciclo de vida de este, así como el encargado de gestionar los recursos usados y referencias a estos.\\
\begin{center}
\includegraphics[scale=0.7]{mrrobottoengine.png}
\end{center}

Para inicializar una instancia de esta clase el usuario requerirá por una parte de un \textit{Context} de la plataforma Android, como podría ser una \textit{Activity} y por otra una referencia a una instancia de \rorefsurfaceview\label{ro:surfaceview}, esta clase hereda de la clase \textit{View} de la plataforma Android y será donde se mostrará el contenido.\\

Una vez se ha obtenido una referencia a un objeto de la clase \rorefrobottoengine el siguiente paso consiste en cargar una escena desde un \textit{stream} de datos. Este \textit{stream} de datos ha de contener datos en el formato MRR.\\
La carga de estos datos puede realizarse de dos formas distintas, de forma bloqueante o de forma no bloqueante, para ello se usarán los métodos \rorefm{MrRobottoEngine}{loadSceneTree-java.io.InputStream-}{loadSceneTree} y \rorefm{MrRobottoEngine}{loadSceneTreeAsync-java.io.InputStream-}{loadSceneTreeAsync} respectivamente.\\

Cuando la carga de datos haya finalizado se llamará automáticamente al método \rorefm{MrRobottoEngine}{onInitialize--}{onInitialize}, este método está pensado para ser sobrescrito en clases que hereden de \rorefrobottoengine ya que proporciona un entorno seguro para acceder a la escena, sus objetos y proporcionar código de iniciación.\\

\subsection{Objetos de la Escena}
Una vez hemos cargado la escena que usaremos nos interesa conocer los distintos objetos que pueden utilizarse.\\

\subsubsection{MrSceneTree}\label{susec:MrSceneTree}
El objeto \rorefscenetree es la interfaz que se le ofrece al usuario para acceder a la escena.\\
Este es el punto de entrada a la hora de acceder a cualquier objeto.


\subsubsection{MrObject}
\rorefobject\label{ro:object} es la clase base de toda nuestra jerarquía y la que contiene los métodos más genéricos para el control de un objeto de la escena.\\
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.8]{robottohierarchy.png}
\end{center}
\caption[Jerarquía de MrObject]{Jerarquía de MrObject}
\label{fig:robottohierarchy}
\end{figure}
A pesar de ser una clase considerablemente importante de cara al uso, esta clase en realidad actúa como un envolvente de una clase de nivel inferior, \textit{MrObjectController}, de la que se hablará más adelante.\\

Las posibles acciones que se pueden realizar con una instancia de \rorefobject podrían dividirse en cuatro grupos según su funcionalidad.\\
Estas son o bien métodos genéricos, como podrían ser el constructor u obtener el tipo de objeto, métodos orientados a la gestión de eventos, como agregar o eliminar un evento a procesar, de jerarquía, como acceder a los hijos o al padre de un objeto, o de transformación, como puede ser rotar, escalar o trasladar el objeto.\\

TODO: Aumentar el tamaño de la fuente
\begin{figure}[h!]
\centering
\subfloat[Métods Genéricos]{
  \includegraphics[scale=0.6]{objgeneric.png}
}
\subfloat[Métodos de Gestión de Eventos]{
  \includegraphics[scale=0.6]{objevents.png}
}
\hspace{0mm}
\subfloat[Métodos de Gestión de JerarQuía]{
  \includegraphics[scale=0.6]{objtree.png}
}
\subfloat[Métodos de Transformaciones Geométricas]{
  \includegraphics[scale=0.6]{objtransform.png}
}
\caption[Métodos de MrObject]{Métodos de MrObject agrupados por funcionalidad.}
\label{fig:metodosmrobject}
\end{figure}

\subsubsection{MrModel, MrCamera, MrLight y MrScene}

\subsection{Eventos}
TODO: Gestión de eventos con mayor detalle, como la interfaz EventListener y EventDispatcher


\subsection{Estructura de los Objetos}
Como se ha comentado ya durante este documento, la clase \rorefobject y todas sus subclases, son interfaces de una estructura subyacente encargada de administrar los objetos de la escena, tanto desde la gestión de eventos, pasando por el renderizado, como la gestión de los datos del objeto de la escena.\\
Dicha estructura podría verse compuesta por tres partes diferenciadas.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{mdr.png}
\end{center}
\caption[Estructura interna de los objetos]{Estructura interna de los objetos.}
\label{fig:mdr}
\end{figure}

Tal y como se puede apreciar en la figura \ref{fig:mdr} la estructura emula al patrón modelo-vista-controlador(MVC), y eso es precisamente lo que se buscaba, tres partes diferenciadas y cada una con unas responsabilidades definidas.

\subsubsection{Contenedores de Datos}
Los contenedores de datos serían la parte del modelo dentro del patrón MVC, su funcionalidad está restringida a almacenar datos necesarios del objeto que serán requeridos o bien por el controlador o bien por la parte del renderizador.\\
Todos los elementos contenedores de datos requieren que se herede de la clase \rorefobjectdata\\
Todos los contenedores de datos se encuentran dentro del paquete \roref{engine/core/data/package-summary}{mr.robotto.engine.core.data}
\subsubsection{Renderizadores}
Los renderizadores hacen la función de la vista dentro del patrón MVC. Se encargan de tomar datos desde el modelo y presentarla como se requiera.\\
Los renderizadores están pensados para que todas las llamadas a OpenGL sean ejecutadas desde aquí, de esta forma todas las llamadas a la API se encontrarán concentradas en unas clases determinadas, lo cuál resulta muy beneficioso en cuanto a mantenibilidad de código se refiere.\\
Todos los objetos que se encarguen del renderizado deben implementar una cierta interfaz denominada \rorefobjectrender en la cuál es necesario implementar los siguientes métodos

\begin{itemize}
\item \texttt{void initializeRender(MrRenderingContext context, MrObjectData link)}\\
En este método al renderer se le asignan el rendering context sobre el cuál trabajará y además el objeto al que estará asociado.\\ 
Además en este método se inicia el objeto desde el punto de vista gráfico, es decir, se realizan tareas tales como configurar texturas, compilar Shader Programs y similares.
\item \texttt{void initializeSizeDependant(int w, int h)}\\
En este método se inician los recursos que dependan del tamaño de la ventana usada en ese momento.
\item \texttt{boolean isInitialized()}\\
Simplemente comprueba si el renderizador ha sido iniciado
\item \texttt{void render()}\\
Este método es el encargado de pasar datos a la tarjeta gráfica en cada frame.
\end{itemize}
Todos los renderizadores de objetos se encuentran dentro del paquete \roref{engine/core/render/package-summary}{mr.robotto.engine.core.render}
\subsubsection{Controladores}
La figura del controlador es la encargada de coordinar y dar sentido a todos los elementos que, en conjunto, conformen un objeto de la escena. 

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{controlleresquema.png}
\end{center}
\caption[Elementos destacables de MrObjectController]{Elementos destacables de MrObjectController}
\label{fig:controlleresquema}
\end{figure}

\subsection{MrObjectController y sus Componentes}

\subsection{MrModelController y sus Componentes}
\subsubsection{Mallas 3D}
TODO: Comentar campos importantes como los VBO e IBO, y como relaciona cada campo de los buffers con los atributos del shader program (este "enlace" entre datos viene especificado en el fichero MRR)
TODO:Agregar como se pasan los attributes\\
\subsubsection{Shaders}
TODO: Shaders, Attributes, Uniforms y Generadores de Uniforms (estos últimos tienen especial interés ya que gracias a ellos en un cierto objeto dado podemos generar un uniform y relacionarlo con un uniform del shader, explicar ese enlace en profundidad en la sección de renderizadores)
\subsubsection{Materiales y Texturas}
TODO:
\subsubsection{Animación}
TODO:Explicar cosas como a partir de los KeyFrames importados desde el fichero se interpola la pose, así como la estructura de un esqueleto, los huesos,...



\subsection{Paquete de Herramientas}
Entre las utilidades más relevantes para el funcionamiento de \robotto cabe destacar el papel de los cargadores de datos, encargados de transformar los ficheros \textit{".mrr"} a la estructura interna del motor, así como las distintas clases encargadas de representar estructuras de datos específicamente implementadas para acomodar los datos usados.

\subsubsection{Cargadores de Datos}
TODO: Explicar como funciona la carga de datos y cómo se realiza una carga paralela de por ejemplo los JSON y las texturas

\subsection{Paquete de Estructuras de Datos}
Para la implementación de partes esenciales de la arquitectura, como por ejemplo, la construcción de la propia escena, se requerían de ciertas estructuras de datos específicas para la aplicación.\\
Este es el caso de \textbf{MrTreeMap}, clase 

Las siguientes estructuras de datos aquí presentadas han sido pensadas tanto como para representar los datos requeridos así como una gran rapidez a la hora de acceder a ellos y realizar búsquedas.\\
Con ese fin se ha desarrollado una herramienta auxiliar denominada \textbf{MrMapFunction}.\\
Esta sencilla clase permite realizar un mapeo directo entre los objetos contenidos en las estructuras y las llaves asociadas a ellos.
$$\text{Object}\mapsto \text{Key}$$


TODO: Comentar las estructuras de datos implementadas, la más relevante, el árbol que luego usas como base clase para implementar el SceneTree

\subsection{Paquete Matemático}
\subsubsection{MrLinearAlgebraObject}
\textbf{MrLinearAlgebraObject} es la interfaz principal de todos los objetos que necesiten por una parte, almacenar datos numéricos, como podrían ser ls componentes de un vector, una matriz,... y por otra usarse como interfaz a la hora de transmitir datos desde la aplicación a la GPU en forma de \textit{uniforms}.
TODO: Clase base de los elementos matemáticos, y no matemáticos, pues será la clase fundamental para poder pasarlos como uniforms
TODO: Comentar la alta optimización de las operaciones
\subsubsection{Matrices}
\subsubsection{Cuaterniones}
\subsubsection{Vectores}
\subsubsection{MrTransforms}
TODO: Clase base de las transformaciones geométricas, comentar cómo se combinan las clases anteriores para ofrecer operaciones tales como rotar alrededor de un punto




\section{Conclusiones y Posibles Mejoras}

TODO: Compartir modelos, mejorar el formato mrr, mala elección de org.json